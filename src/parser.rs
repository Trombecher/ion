use crate::ast::{Expression, MarkupElement};
use crate::lexer::Lexer;
use crate::token::{Symbol, Token, WithSpan};
use crate::{bp, ion};

#[derive(Debug)]
pub enum Error {
    UnexpectedToken,
}

pub struct Parser<'a> {
    lexer: Lexer<'a>,
    pub last_token: WithSpan<Token>,
}

impl<'a> Parser<'a> {
    pub fn new(mut lexer: Lexer<'a>) -> Result<Self, ion::Error> {
        Ok(Self {
            last_token: lexer.next()?,
            lexer,
        })
    }

    fn next_token(&mut self) -> Result<(), ion::Error> {
        self.last_token = self.lexer.next()?;
        Ok(())
    }

    pub fn parse_block(&mut self) -> Result<Vec<WithSpan<Expression>>, ion::Error> {
        let mut expressions = Vec::new();

        loop {
            expressions.push(self.parse_expression(bp::COMMA_AND_SEMICOLON)?);

            match &self.last_token.value {
                Token::Symbol(Symbol::Semicolon) => self.next_token()?,
                Token::EndOfInput | Token::Symbol(Symbol::RightBrace) => return Ok(expressions),
                _ => return Err(ion::Error::Parser(Error::UnexpectedToken)),
            }
        }
    }

    pub fn parse_expression(&mut self, min_bp: u8) -> Result<WithSpan<Expression>, ion::Error> {
        let start = self.last_token.start;

        let mut left_side = match &self.last_token.value {
            Token::Number(number) => {
                let number = WithSpan {
                    value: Expression::Number(*number),
                    start,
                    end: self.last_token.end,
                };
                self.next_token()?;
                number
            }
            Token::String(string) => {
                let string = WithSpan {
                    value: Expression::String(string.clone()),
                    start,
                    end: self.last_token.end,
                };
                self.next_token()?;
                string
            }
            Token::Symbol(Symbol::LeftBrace) => {
                self.next_token()?;
                let block = self.parse_block()?;

                match &self.last_token.value {
                    Token::Symbol(Symbol::RightBrace) => {}
                    _ => return Err(ion::Error::Parser(Error::UnexpectedToken)),
                }

                let block = WithSpan {
                    value: Expression::Block(block),
                    start,
                    end: self.last_token.end,
                };
                self.next_token()?;
                block
            }
            Token::MarkupStartTag(element) => {
                let identifier = WithSpan {
                    value: element.clone(),
                    start,
                    end: self.last_token.end
                };
                
                let mut attributes = Vec::new();

                loop {
                    self.next_token()?;
                    
                    let key = WithSpan {
                        start: self.last_token.start,
                        value: match &self.last_token.value {
                            Token::MarkupKey(key) => key.clone(),
                            Token::MarkupStartTagEnd => break,
                            Token::MarkupClose => break,
                            token => unreachable!("Got token: {:?}. This token should not have been generated by the lexer.", token)
                        },
                        end: self.last_token.end,
                    };
                    
                    self.next_token()?;
                    
                    let value = WithSpan {
                        start: self.last_token.start,
                        value: match &self.last_token.value {
                            Token::Symbol(Symbol::LeftBrace) => Expression::Block(self.parse_block()?),
                            Token::String(s) => Expression::String(s.clone()),
                            token => unreachable!("Got token: {:?}. This token should not have been generated by the lexer.", token)
                        },
                        end: self.last_token.end
                    };
                    
                    attributes.push((key, value));
                }
                
                let element = WithSpan {
                    value: Expression::Markup(MarkupElement {
                        identifier,
                        attributes,
                        children: vec![],
                    }),
                    start,
                    end: self.last_token.end,
                };
                self.next_token()?;
                element
            },
            token => todo!("{:?}", token),
        };

        macro_rules! op {
            ($e: expr, $bp: expr) => {{
                if $bp.0 < min_bp {
                    break;
                }

                self.next_token()?;

                WithSpan {
                    value: $e(Box::new(left_side), Box::new(self.parse_expression($bp.1)?)),
                    start,
                    end: self.last_token.end,
                }
            }};
        }

        loop {
            left_side = match &self.last_token.value {
                Token::Symbol(Symbol::Plus) => op!(Expression::Addition, bp::ADDITIVE),
                Token::Symbol(Symbol::Minus) => op!(Expression::Subtraction, bp::ADDITIVE),
                Token::Symbol(Symbol::Star) => op!(Expression::Multiplication, bp::MULTIPLICATIVE),
                Token::Symbol(Symbol::Slash) => op!(Expression::Division, bp::MULTIPLICATIVE),
                Token::Symbol(Symbol::Percent) => op!(Expression::Remainder, bp::MULTIPLICATIVE),
                Token::Symbol(Symbol::StarStar) => op!(Expression::Exponentiation, bp::EXPONENTIAL),
                Token::Symbol(Symbol::Pipe) => op!(Expression::BitwiseOr, bp::BITWISE_OR),
                Token::Symbol(Symbol::Ampersand) => op!(Expression::BitwiseAnd, bp::BITWISE_AND),
                Token::Symbol(Symbol::Caret) => {
                    op!(Expression::BitwiseExclusiveOr, bp::BITWISE_XOR)
                }
                Token::Symbol(Symbol::PipePipe) => op!(Expression::LogicalOr, bp::LOGICAL_OR),
                Token::Symbol(Symbol::AmpersandAmpersand) => {
                    op!(Expression::LogicalAnd, bp::LOGICAL_AND)
                }
                Token::Symbol(Symbol::LeftAngleLeftAngle) => op!(Expression::ShiftLeft, bp::SHIFT),
                Token::Symbol(Symbol::RightAngleRightAngle) => {
                    op!(Expression::ShiftRight, bp::SHIFT)
                }

                Token::Symbol(Symbol::EqualsEquals) => op!(Expression::Equals, bp::EQUALITY),
                Token::Symbol(Symbol::ExclamationMarkEquals) => {
                    op!(Expression::NotEquals, bp::EQUALITY)
                }
                Token::Symbol(Symbol::LeftAngle) => op!(Expression::LessThan, bp::RELATIONAL),
                Token::Symbol(Symbol::LeftAngleEquals) => {
                    op!(Expression::LessThanOrEqual, bp::RELATIONAL)
                }
                Token::Symbol(Symbol::RightAngle) => op!(Expression::GreaterThan, bp::RELATIONAL),
                Token::Symbol(Symbol::RightAngleEquals) => {
                    op!(Expression::GreaterThanOrEqual, bp::RELATIONAL)
                }
                Token::Symbol(Symbol::Semicolon)
                | Token::Symbol(Symbol::Comma)
                | Token::EndOfInput
                | Token::Symbol(Symbol::RightBrace)
                | Token::Symbol(Symbol::RightParenthesis) => break,
                token => todo!("{:?}", token),
            }
        }

        Ok(left_side)
    }
}
